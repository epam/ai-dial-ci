name: "Generate release notes"
description: "Generate release notes based on conventional commits"

inputs:
  latest_tag:
    description: "Semantically latest git tag in the repository"
    required: true

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      with:
        fetch-depth: 0
        lfs: true
    - name: Generate changelog
      id: generate_changelog
      shell: bash
      env:
        INPUT_LATEST_TAG: ${{ inputs.latest_tag }}
      run: |
        #!/bin/bash

        # This script generates a changelog based on the commits since the last tag in the repository or the latest tag specified as an input.
        # It categorizes the commits into features, fixes, and other changes.
        # The script outputs the changelog to a file named my_changelog in the /tmp directory.

        # set -x

        latest_tag_repo="${INPUT_LATEST_TAG}"                                      # Trying to obtain the last tag if provided as ENV variable
        latest_tag_branch=$(git describe --tags --abbrev=0 2>/dev/null || echo '') # Trying to obtain the latest GIT tag in the current branch

        # Local branch tags should have priority.
        # If no tags are found in both methods, it sets LAST_TAG as 'NO'
        LAST_TAG="${latest_tag_branch:-${latest_tag_repo:-NO}}"

        # Fetch all commit messages if no tags found, else fetch messages since the LAST_TAG
        if [[ "${LAST_TAG}" == "NO" ]]; then
            git log --pretty=format:"%s" >/tmp/my_commits_log
        else
            git log "${LAST_TAG}"..HEAD --pretty=format:"%s" >/tmp/my_commits_log
        fi

        sort --unique --output /tmp/my_commits_log{,} # Sorting commits and removing duplicates

        sed -i '/\[skip ci\] Update version/d' /tmp/my_commits_log # Removing '[skip ci] Update version' commits

        # Creating empty files for each category.
        echo -n '' >/tmp/my_changelog_features
        echo -n '' >/tmp/my_changelog_fixes
        echo -n '' >/tmp/my_changelog_other
        echo -n '' >/tmp/my_changelog

        # Regular expression patterns for categorizing commits
        FEATURES_REGEX="^feat:|^feature:"
        FIXES_REGEX="^fix:|^hotfix:"

        # Separating feature commits
        { grep -E "${FEATURES_REGEX}" /tmp/my_commits_log || echo -n ''; } | while read -r l; do
            DESCRIPTION=$(echo "${l}" | sed "s/^feat://;s/^feature://") # Removing leading keywords for neat display
            echo "* ${DESCRIPTION}" >>/tmp/my_changelog_features
        done

        # Separating fix commits
        { grep -E "${FIXES_REGEX}" /tmp/my_commits_log || echo -n ''; } | while read -r l; do
            DESCRIPTION=$(echo "${l}" | sed "s/^fix://;s/^hotfix://")
            echo "* ${DESCRIPTION}" >>/tmp/my_changelog_fixes
        done

        # Separating other commits
        { grep -Ev "${FEATURES_REGEX}|${FIXES_REGEX}" /tmp/my_commits_log || echo -n ''; } | while read -r l; do
            echo "* ${l}" >>/tmp/my_changelog_other
        done

        # Creating the final changelog file with markdown syntax
        # features
        if [[ "$(wc -l </tmp/my_changelog_features)" -gt 0 ]]; then
            {
                echo "### Features:"
                cat /tmp/my_changelog_features
                echo ""
            } >>/tmp/my_changelog
        fi

        # fixes
        if [[ "$(wc -l </tmp/my_changelog_fixes)" -gt 0 ]]; then
            {
                echo "### Fixes:"
                cat /tmp/my_changelog_fixes
                echo ""
            } >>/tmp/my_changelog
        fi

        # other
        if [[ "$(wc -l </tmp/my_changelog_other)" -gt 0 ]]; then
            {
                echo "### Other:"
                grep -v "Merge branch " /tmp/my_changelog_other
                echo ""
            } >>/tmp/my_changelog
        fi
